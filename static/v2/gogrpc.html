<!DOCTYPE html>
<html lang="en">
	<head>
        <!-- GOOGLE ANALYTICS SNIPPET -->
        <!-- Global site tag (gtag.js) - Google Analytics -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=UA-115468315-1"></script>
        <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            
            gtag('config', 'UA-115468315-1');
        </script>
        <!-- END GOOGLE ANALYTICS -->
        
		<meta charset="utf-8">

		<!-- Always force latest IE rendering engine -->
		<meta http-equiv="X-UA-Compatible" content="IE=edge">

		<!-- Mobile Specific Meta -->
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<meta name="description" content="DESCRIPTION">
		<meta name="keywords" content="KEYWORDS">
		<meta name="author" content="AUTHOR NAME">

		<!-- TITLE -->
		<title>Go gRPC</title>

		<!-- FAVICON -->
	    <link href=favicon.ico rel="icon">
        <link rel="apple-touch-icon" sizes="72x72" href="favicon/apple-icon-72x72.png">
        <link rel="apple-touch-icon" sizes="76x76" href="favicon/apple-icon-76x76.png">
        <link rel="apple-touch-icon" sizes="114x114" href="favicon/apple-icon-114x114.png">
        <link rel="manifest" href="favicon/site.webmanifest">
		<link rel="apple-touch-icon" href="favicon/apple-touch-icon.png">
        <meta name="msapplication-TileColor" content="#2d89ef">
        <meta name="theme-color" content="#ffffff">

		<!-- BOOTSTRAP CSS -->
		<link rel="stylesheet" href="css/bootstrap/bootstrap.min.css">

		<!-- FONT-AWESOME & ET-LINE-FONT CSS -->
		<link rel="stylesheet" href="css/font-awesome/css/font-awesome.min.css">
		<link rel="stylesheet" href="css/et-line-font/et-line-font.css">

	    <!-- MAGNIFIC POPUP CORE CSS -->
	    <link href="css/magnific-popup/magnific-popup.css" rel="stylesheet">

        <!-- OWL CAROUSEL -->
        <link href="css/owl-carousel/owl.carousel.min.css" rel="stylesheet">
        <link href="css/owl-carousel/owl.theme.default.min.css" rel="stylesheet">

		<!-- MAIN STYLE CSS -->
		<link rel="stylesheet" href="css/style.css">

		<!-- RESPONSIVE STYLE CSS -->
		<link rel="stylesheet" href="css/responsive.css">
		
		<!-- COLORS CSS -->
		<link rel="stylesheet" href="css/colors/red.css">

	</head>
	<body>

		<!-- ====== Preloader ======  -->
	    <div class="loading">
			<div class="load-circle">
			</div>
		</div>
		<!-- ======End Preloader ======  -->

		<!-- ====== HEADER START ======  -->
		<section class="t-header" id="home" data-scroll-index="0">
			<div class="header-overlay">

				<!-- ====== NAVGITION ======  -->
				<nav class="navbar land-nav navbar-fixed-top">
					<div class="container">
						<div class="row">
							<!-- Brand and toggle get grouped for better mobile display -->
							<div class="navbar-header">
								<button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#collapse" aria-expanded="false">
								<span class="sr-only">Toggle navigation</span>
								<span class="icon-bar"></span>
								<span class="icon-bar"></span>
								<span class="icon-bar"></span>
								</button>
                                
								<!-- logo -->
                                <a class="logo navbar-brand" href="index.html"><ul><li><img src="img/logo-sm.png"/> Open<span>Census</span></li></ul>
								</a>
							</div>

							<!-- Collect the nav links, and other content for toggling -->
							<div class="collapse navbar-collapse" id="collapse">

								<!-- links -->
								<ul class="nav navbar-nav navbar-right" id="navbar">
								    <li><a href="overview.html">Overview</a></li>
                                    
                                    <!-- LANGUAGES NAV DROPDOWN  -->
                                    <ul class="nav navbar-nav">
                                        <li class="dropdown">
                                           <a href="#" class="dropdown-toggle" data-toggle="dropdown" style="margin-left:10px"> Languages <b class="caret"></b></a>
                                           <ul class="dropdown-menu">
                                              <div class="row">
                                                 <div class="col-sm-4">
                                                    <ul class="multi-column-dropdown">
                                                        <li style="droplist"><a href="cpp.html">C++</a></li>
														<li style="droplist"><a href="go.html">Go</a></li>
                                                    </ul>
                                                 </div>
                                                 <div class="col-sm-4">
                                                    <ul class="multi-column-dropdown">
                                                        <li style="droplist"><a href="erlang.html">Erlang</a></li>
														<li style="droplist"><a href="java.html">Java</a></li>
														<li style="droplist"><a href="ruby.html">Ruby</a></li>
                                                    </ul>
                                                 </div>
                                                 <div class="col-sm-4">
                                                    <ul class="multi-column-dropdown">
                                                        <li style="droplist"><a href="php.html">PHP</a></li>
														<li style="droplist"><a href="python.html">Python</a></li>
                                                    </ul>
                                                 </div>
                                              </div>
                                           </ul>
                                       </li>   
                                    </ul>
                                    <!-- END LANGUAGES NAV DROPDOWN -->            
									<li><a href="docs.html">Docs</a></li>
									<!--<li><a href="spanner.html">Tutorial</a></li>-->
                                    <li><a href="glossary.html">Glossary</a></li>
									<li><a href="roadmap.html">Roadmap</a></li>
									<li><a href="blog.html">Blog</a></li>
									<li><a href="faq.html">FAQ</a></li>
                                    <li><a href="about.html">About</a></li>
								</ul>
							</div><!-- /.navbar-collapse -->
						</div>
					</div><!-- /.container -->
				</nav>
				<!-- ====== END NAVGITION ======  -->
			</div>            
		</section>
		<!-- ====== HEADER END ======  -->


        <!-- ====== GO gRPC START  ======  -->
		<section class="sections lang" id="lang">            
			<div class="container">
				<div class="row">   
					<!-- GO gRPC CONTENT START -->
                    <div class="title">
                        
                        <!-- CENTER COULMN -->
                        <div class="col-md-12 box">
                        <h1>OpenCensus for Go gRPC developers</h1>
                          <br /><br />
                            <p>In this tutorial, we’ll examine how to use OpenCensus in your gRPC projects in the Go programming language for observability both into your server and then client! We’ll then examine how we can integrate with OpenCensus exporters from AWS X-Ray, Prometheus, Zipkin and Google Stackdriver Tracing and Monitoring.</p><br /><hr><br />
							
							<p>gRPC is a modern high performance framework for remote procedure calls, powered by Protocol Buffer encoding. It is polyglot in nature, accessible and useable on a variety of environments ranging from mobile mobile devices, general purpose computers to data centres for distributed computing, and it is implemented in a variety of languages: Go, Java, Python, C/C++, Node.js, Ruby, PHP <a href="https://grpc.io/" target="_blank"><span class="gloss1">https://grpc.io/</span></a>.</p><br />
							
							<p>OpenCensus is a modern observability framework for distributed tracing and monitoring across microservices and monoliths alike. It is polyglot in nature, accessible and useable too on a variety of environments from mobile devices, general purpose computers and data centres for distributed computing and it is implemented in a plethora of languages: Go, Java, Python, C++, Node.js, Ruby, PHP, C#(coming soon) <a href="https://opencensus.io/"><span class="gloss1">https://opencensus.io/</span></a>.</p><br />
							
							<p>Go is a modern programming language that powers the cloud as well as modern systems programming, making it easy to build simple, reliable and efficient software. It is a cross platform, fast, statically typed and a simple language <a href="https://golang.org" target="_blank"><span class="gloss1">https://golang.org</span></a>.</p><br />
							
							<p>With the above three introductory paragraphs, perhaps you already noticed the common themes: high performance, distributed computing, modern nature, cross platform, simplicity, reliability — those points make the three a match #compatibility, hence the motivation for this tutorial/article.</p><br /><hr><br />
							
							<p>For this tutorial, we have a company’s service that’s in charge of capitalizing letters sent in from various clients and internal microservices using gRPC.</p><br />

							<p>To use gRPC, we firstly need to create Protocol Buffer definitions and from those, use the Protocol Buffer compiler with the gRPC plugin to generate code stubs. If you need to take a look at the pre-requisites or a primer into gRPC, please check out this article <a href="https://grpc.io/docs/" target="_blank"><span class="gloss1">https://grpc.io/docs/</span></a>.</p><br />

							<p>Our service takes in a payload with bytes, and then capitalizes them on the server.</p><br />
							
<p><pre><code>syntax = "proto3";

package rpc;

message Payload {
	int32 id    = 1;
	bytes data  = 2;
}

service Fetch {
	rpc Capitalize(Payload) returns (Payload) {}
}</code></pre></p>
							
							<p style="text-align:center;">Payload Message and Fetch service</p><br /><br />
							
							<p>To generate code, we’ll firstly put our definition in a file called “defs.proto” and move it into our “rpc” directory and then run this command to generate gRPC code stubs in Go, using this Makefile below:</p><br />
							
<p><pre><code>protoc:
protoc -I rpc rpc/defs.proto --go_out=plugins=grpc:rpc</code></pre></p>
							
							<p style="text-align:center;">Makefile</p><br /><br />
							
							<p><span class="code1">make</span> should then generate code that’ll make the directory structure look like this</p><br />
							
<p><pre><code>|-rpc/
   |-defs.proto
   |-defs.pb.go</code></pre></p><br />
							
							<p>After the code generation, we now need to add the business logic into the server</p><br /><hr><br />
							
							<p><h3>Plain Server</h3><br />
							Our server’s sole purpose is to capitalize content sent in and send it back to the client. With gRPC, as previously mentioned, the protoc plugin generated code for a server interface. This allows you create your own custom logic of operation, as we shall do below with a custom object that implements the <span class="code1">Capitalize</span> method.</p><br />
							
<p><pre><code>package main

import (
	"bytes"
	"context"
	"log"
	"net"

	"google.golang.org/grpc"

	"./rpc"
)

type fetchIt int

// Compile time assertion that fetchIt implements FetchServer.
var _ rpc.FetchServer = (*fetchIt)(nil)

func (fi *fetchIt) Capitalize(ctx context.Context, in *rpc.Payload) (*rpc.Payload, error) {
	out := &rpc.Payload{
		Data: bytes.ToUpper(in.Data),
	}
	return out, nil
}

func main() {
	addr := ":9988"
	ln, err := net.Listen("tcp", addr)
	if err != nil {
		log.Fatalf("gRPC server: failed to listen: %v", err)
	}
	srv := grpc.NewServer()
	rpc.RegisterFetchServer(srv, new(fetchIt))
	log.Printf("fetchIt gRPC server serving at %q", addr)
	if err := srv.Serve(ln); err != nil {
		log.Fatalf("gRPC server: error serving: %v", err)
	}
}</code></pre></p>
							
							<p style="text-align:center;">server.go</p><br />
							
							<p>With that, we can now monetize access to generate money $$$. In order to accomplish that though, we need to create clients that speak gRPC and for that please see below:</p><br /><hr><br />
							
							<p><h3>Plain Client</h3><br />
							Our client makes a request to the gRPC server above, sending content that then gets capitalized and printed to our screen. It is interactive and can be run simply by <span class="code1">go run client.go</span></p><br />
							
<p><pre><code>package main

import (
	"bufio"
	"context"
	"fmt"
	"log"
	"os"

	"google.golang.org/grpc"

	"./rpc"
)

func main() {
	serverAddr := ":9988"
	cc, err := grpc.Dial(serverAddr, grpc.WithInsecure())
	if err != nil {
		log.Fatalf("fetchIt gRPC client failed to dial to server: %v", err)
	}
	fc := rpc.NewFetchClient(cc)

	fIn := bufio.NewReader(os.Stdin)
	for {
		fmt.Print("> ")
		line, _, err := fIn.ReadLine()
		if err != nil {
			log.Fatalf("Failed to read a line in: %v", err)
		}

		ctx := context.Background()
		out, err := fc.Capitalize(ctx, &amp;rpc.Payload{Data: line})
		if err != nil {
			log.Printf("fetchIt gRPC client got error from server: %v", err)
			continue
		}
		fmt.Printf("&lt; %s\n\n", out.Data)
	}
}</code></pre></p><br />
							
							<p>which when run interactively, will look like this</p><br />
							
							<p><img src="https://cdn-images-1.medium.com/max/800/1*rvkG7rff2y5Diy-64j74DQ.png" /></p>
							
							<p style="text-align:center;">interactive response from the client</p><br />
							
							<p>And now that we have a client, we are open for business!!</p><br /><hr><br />
							
							<p><h3>Aftermath</h3><br />
							It’s been 1 hour since launch. Tech blogs and other programmers are sharing news of our service all over their internet and social media; our service just got so popular and is being talked about all around the business world too, high fives are shared and congrats shared — after this celebration, we all go back home and call it a night. It’s the latest and greatest API in the world, it is off the charts, customers from all over the world come in, what could go wrong?</p><br />

							<p>It hits 3AM and our servers start getting over loaded. Response time degrades overall for everyone. This however is only noticed after one of the engineers tried to give a demo to their family that they restlessly awoke at 2:00AM due to excitement, but the service is taking 15ms to give back a response. In normal usage, we saw about at most 1ms response time. What is causing the sluggishness of the system? When did our service start getting slow? What is the solution? Throw more servers at it? How many servers should we throw at it? How do we know what is going wrong? When? How can the engineering and business teams figure out what to optimize or budget for? How can we tell we’ve successfully optimized the system and removed bottlenecks?</p><br />
							
							<p>In comes in OpenCensus: OpenCensus is a single distribution of libraries for distributed tracing and monitoring for modern and distributed systems. OpenCensus can help answer mostly all of those questions that we asked. By “mostly”, I mean that it can answer the observability related questions such as: When did the latency increase? Why? How did it increase? By how much? What part of the system is the slowest? How can we optimize and assert successful changes?</p><br />

							<p>OpenCensus is simple to integrate and use, it adds very low latency to your applications and it is already integrated into both gRPC and HTTP transports.</p><br />

							<p>OpenCensus allows you to trace and measure once and then export to a variety of backends like Prometheus, AWS X-Ray, Stackdriver Tracing and Monitoring, Jaeger, Zipkin etc. With that mentioned, let’s get started.</p><br /><br />
							
							<p><h3>Part 1: observability by instrumenting the server</h3><br />
							To collect statistics from gRPC servers, OpenCensus is already integrated with gRPC out of the box, and one just has to import <span class="code1">go.opencensus.io/plugin/ocgrpc</span>. And then also subscribe to the gRPC server views. This amounts to a 7 line change</p><br />
							
<p><pre><code>10a11,13
> 	"go.opencensus.io/plugin/ocgrpc"
> 	"go.opencensus.io/stats/view"
> 
32c35,38
< 	srv := grpc.NewServer()
---
> 	if err := view.Register(ocgrpc.DefaultServerViews...); err != nil {
> 		log.Fatalf("Failed to register gRPC server views: %v", err)
> 	}
> 	srv := grpc.NewServer(grpc.StatsHandler(new(ocgrpc.ServerHandler)))</code></pre></p><br />
							
							<p>and then to trace the application, we’ll start a span on entering the function, then end it on exiting. This amounts to a 7 line change too</p><br />
							
<p><pre><code>12a13
> 	"go.opencensus.io/trace"
22a24,29
> 	_, span := trace.StartSpan(ctx, "(*fetchIt).Capitalize")
> 	defer span.End()
> 
> 	span.Annotate([]trace.Attribute{
> 		trace.Int64Attribute("len", int64(len(in.Data))),
> 	}, "Data in")</code></pre></p><br />
							
							<p>In the tracing, notice the <span class="code1">trace.StartSpan(ctx, "(*fetchIt).Capitalize")</span>? We take a <span class="code1">context.Context</span> as the first argument, to use context propagation which carries over RPC specific information about a request to uniquely identify it.</p><br />
							
							<p><h3>How do we examine that “observability”?</h3><br />
							Now that we’ve got tracing and monitoring in, let’s export that data out. Earlier on, I made claims that with OpenCensus you collect and trace once, then export to a variety of backends, simulatenously. Well, it is time for me to walk that talk!</p><br />

							<p>To do that, we’ll need to use the exporter integrations in our app to send data to our favorite backends: AWS X-Ray, Prometheus, Stackdriver Tracing and Monitoring</p><br />

<p><pre><code>7a8
> 	"net/http"
10a12,14
> 	xray "github.com/census-instrumentation/opencensus-go-exporter-aws"
> 	"go.opencensus.io/exporter/prometheus"
> 	"go.opencensus.io/exporter/stackdriver"
12a17
> 	"go.opencensus.io/trace"
22a28,33
> 	_, span := trace.StartSpan(ctx, "(*fetchIt).Capitalize")
> 	defer span.End()
> 
> 	span.Annotate([]trace.Attribute{
> 		trace.Int64Attribute("len", int64(len(in.Data))),
> 	}, "Data in")
40a52,56
> 
> 	// OpenCensus exporters
> 	createAndRegisterExporters()
> 
> 	// Finally serve
44a61,97
> 
> func createAndRegisterExporters() {
> 	// For demo purposes, set this to always sample.
> 	trace.ApplyConfig(trace.Config{DefaultSampler: trace.AlwaysSample()})
> 	// 1. Prometheus
> 	prefix := "fetchit"
> 	pe, err := prometheus.NewExporter(prometheus.Options{
> 		Namespace: prefix,
> 	})
> 	if err != nil {
> 		log.Fatalf("Failed to create Prometheus exporter: %v", err)
> 	}
> 	view.RegisterExporter(pe)
> 	// We need to expose the Prometheus collector via an endpoint /metrics
> 	go func() {
> 		mux := http.NewServeMux()
> 		mux.Handle("/metrics", pe)
> 		log.Fatal(http.ListenAndServe(":9888", mux))
> 	}()
> 
> 	// 2. AWS X-Ray
> 	xe, err := xray.NewExporter(xray.WithVersion("latest"))
> 	if err != nil {
> 		log.Fatalf("Failed to create AWS X-Ray exporter: %v", err)
> 	}
> 	trace.RegisterExporter(xe)
> 
> 	// 3. Stackdriver Tracing and Monitoring
> 	se, err := stackdriver.NewExporter(stackdriver.Options{
> 		MetricPrefix: prefix,
> 	})
> 	if err != nil {
> 		log.Fatalf("Failed to create Stackdriver exporter: %v", err)
> 	}
> 	view.RegisterExporter(se)
> 	trace.RegisterExporter(se)
> }</code></pre></p><br />
							
							<p>to finally give this code</p><br />
							
<p><pre><code>package main

import (
	"bytes"
	"context"
	"log"
	"net"
	"net/http"

	"google.golang.org/grpc"

	xray "github.com/census-instrumentation/opencensus-go-exporter-aws"
	"go.opencensus.io/exporter/prometheus"
	"go.opencensus.io/exporter/stackdriver"
	"go.opencensus.io/plugin/ocgrpc"
	"go.opencensus.io/stats/view"
	"go.opencensus.io/trace"

	"./rpc"
)

type fetchIt int

// Compile time assertion that fetchIt implements FetchServer.
var _ rpc.FetchServer = (*fetchIt)(nil)

func (fi *fetchIt) Capitalize(ctx context.Context, in *rpc.Payload) (*rpc.Payload, error) {
	_, span := trace.StartSpan(ctx, "(*fetchIt).Capitalize")
	defer span.End()

	span.Annotate([]trace.Attribute{
		trace.Int64Attribute("len", int64(len(in.Data))),
	}, "Data in")
	out := &rpc.Payload{
		Data: bytes.ToUpper(in.Data),
	}
	return out, nil
}

func main() {
	addr := ":9988"
	ln, err := net.Listen("tcp", addr)
	if err != nil {
		log.Fatalf("gRPC server: failed to listen: %v", err)
	}
	if err := view.Register(ocgrpc.DefaultServerViews...); err != nil {
		log.Fatalf("Failed to register gRPC server views: %v", err)
	}
	srv := grpc.NewServer(grpc.StatsHandler(new(ocgrpc.ServerHandler)))
	rpc.RegisterFetchServer(srv, new(fetchIt))
	log.Printf("fetchIt gRPC server serving at %q", addr)

	// OpenCensus exporters
	createAndRegisterExporters()

	// Finally serve
	if err := srv.Serve(ln); err != nil {
		log.Fatalf("gRPC server: error serving: %v", err)
	}
}

func createAndRegisterExporters() {
	// For demo purposes, set this to always sample.
	trace.ApplyConfig(trace.Config{DefaultSampler: trace.AlwaysSample()})
	// 1. Prometheus
	prefix := "fetchit"
	pe, err := prometheus.NewExporter(prometheus.Options{
		Namespace: prefix,
	})
	if err != nil {
		log.Fatalf("Failed to create Prometheus exporter: %v", err)
	}
	view.RegisterExporter(pe)
	// We need to expose the Prometheus collector via an endpoint /metrics
	go func() {
		mux := http.NewServeMux()
		mux.Handle("/metrics", pe)
		log.Fatal(http.ListenAndServe(":9888", mux))
	}()

	// 2. AWS X-Ray
	xe, err := xray.NewExporter(xray.WithVersion("latest"))
	if err != nil {
		log.Fatalf("Failed to create AWS X-Ray exporter: %v", err)
	}
	trace.RegisterExporter(xe)

	// 3. Stackdriver Tracing and Monitoring
	se, err := stackdriver.NewExporter(stackdriver.Options{
		MetricPrefix: prefix,
	})
	if err != nil {
		log.Fatalf("Failed to create Stackdriver exporter: %v", err)
	}
	view.RegisterExporter(se)
	trace.RegisterExporter(se)
}</code></pre></p>
							
							<p style="text-align:center;">OpenCensus instrumented server.go</p><br />
							
							<p>and with the following variables set in our environment</p><br />

							<p><span class="code1">AWS_REGION=region</span></p><br />

							<p><span class="code1">AWS_ACCESS_KEY_ID=keyID</span></p><br />

							<p><span class="code1">AWS_SECRET_ACCESS_KEY=key</span></p><br />

							<p><span class="code1">GOOGLE_APPLICATION_CREDENTIALS=credentials.json</span></p><br />

							<p>as well as our prometheus.yml file</p><br />
							
<p><pre><code>global:
  scrape_interval: 10s

  external_labels:
    monitor: 'media_search' 

scrape_configs:
  - job_name: 'media_search'

    scrape_interval: 10s

    static_configs:
      - targets: ['localhost:9888', 'localhost:9988', 'localhost:9989']</code></pre></p><br />
							
							<p><span class="code1">prometheus --config.file=prometheus.yml</span></p><br />

							<p><span class="code1">go run server.go</span></p><br />

							<p><span class="code1">2018/05/12 11:40:17 fetchIt gRPC server serving at ":9988"</span></p><br /><br />

							<p><h3>Monitoring results</h3></p><br />
							
							<p><img src="https://cdn-images-1.medium.com/max/800/1*29bVdvaQxMH9_c34gkUJcw.png" /></p>
							
							<p style="text-align:center;">Prometheus latency bucket examinations</p><br /><br />
							
							<p><img src="https://cdn-images-1.medium.com/max/800/1*iV9rSPvDjUaWeMJQ756oYQ.png" /></p>
							
							<p style="text-align:center;">Prometheus completed_rpcs examination</p><br /><br />
							
							<p><img src="https://cdn-images-1.medium.com/max/800/1*R-_OpHEDyHe2VL7r3-vcIw.png" /></p>
							
							<p style="text-align:center;">Prometheus sent_bytes_per_rpc_bucket examination</p><br /><br />

							<p><img src="https://cdn-images-1.medium.com/max/800/1*pEwlM76GW5gJbZbWTUD5Cw.png" /></p>
							
							<p style="text-align:center;">Stackdriver Monitoring completed_rpcs examination</p><br /><br />
							
							<p><img src="https://cdn-images-1.medium.com/max/800/1*bON1bvwFXxpDNEVABQ-UZQ.png" /></p>
							
							<p style="text-align:center;">Stackdriver Monitoring server_latency examination</p><br /><br />
							
							<p><h3>Tracing results</h3></p><br />
							
							<p><img src="https://cdn-images-1.medium.com/max/800/1*5gACz0J1DifcjZdQBoFXQQ.png" /></p>
							
							<p style="text-align:center;">Common case: low latency on the server</p><br /><br />

							<p><img src="https://cdn-images-1.medium.com/max/800/1*BqjljxH73vuQYoLY6mQ5yg.png" /></p>
							
							<p style="text-align:center;">Postulation: pathological case of inbound network congestion</p><br /><br />
							
							<p><img src="https://cdn-images-1.medium.com/max/800/1*CJUF7vKUFN8-vk1EzYGf7w.png" /></p>
							
							<p style="text-align:center;">Postulation: pathological case of outbound network congestion</p><br /><br />
							
							<p><img src="https://cdn-images-1.medium.com/max/800/1*FRS-wp8mgrV08-iQCfomyg.png" /></p>
							
							<p style="text-align:center;">Stackdriver Trace — common case, fast response, low latency</p><br /><br />
							
							<p><img src="https://cdn-images-1.medium.com/max/800/1*ghEB4UJ2_qIjZt2esz2anw.png" /></p><br />
                            
                            <p style="text-align:center;">Postulation: system overload on server hence long time for bytes.ToUpper to return</p><br /><br />
							
							<p><img src="https://cdn-images-1.medium.com/max/800/1*-JN7dtnP83fpw8oQ7WtVkA.png" /></p><br />
							
							<p style="text-align:center;">Postulation: outbound network congestion</p><br /><br />

							<p><img src="https://cdn-images-1.medium.com/max/800/1*Q0JmvVQ_yu2nsfhzBnWPiQ.png" /></p><br />
							
							<p style="text-align:center;">Postulation: inbound network congestion</p><br /><br />
							
							<p><h3>Part 2: observability by instrumenting the client</h3><br />
							and then for client monitoring, we’ll just do the same thing for gRPC stats handler except using the ClientHandler and then also start and stop a trace and that’s it, collectively giving this diff below</p><br />
							
<p><pre><code>7a8
> 	"net/http"
11a13,19
> 	xray "github.com/census-instrumentation/opencensus-go-exporter-aws"
> 	"go.opencensus.io/exporter/prometheus"
> 	"go.opencensus.io/exporter/stackdriver"
> 	"go.opencensus.io/plugin/ocgrpc"
> 	"go.opencensus.io/stats/view"
> 	"go.opencensus.io/trace"
> 
17c25
< 	cc, err := grpc.Dial(serverAddr, grpc.WithInsecure())
---
> 	cc, err := grpc.Dial(serverAddr, grpc.WithInsecure(), grpc.WithStatsHandler(new(ocgrpc.ClientHandler)))
22a31,38
> 	// OpenCensus exporters for the client since disjoint
> 	// and your customers will usually want to have their
> 	// own statistics too.
> 	createAndRegisterExporters()
> 	if err := view.Register(ocgrpc.DefaultClientViews...); err != nil {
> 		log.Fatalf("Failed to register gRPC client views: %v", err)
> 	}
> 
31c47
< 		ctx := context.Background()
---
> 		ctx, span := trace.StartSpan(context.Background(), "Client.Capitalize")
32a49
> 		span.End()
39c56,93
< }
\ No newline at end of file
---
> }
> 
> func createAndRegisterExporters() {
> 	// For demo purposes, set this to always sample.
> 	trace.ApplyConfig(trace.Config{DefaultSampler: trace.AlwaysSample()})
> 	// 1. Prometheus
> 	prefix := "fetchit"
> 	pe, err := prometheus.NewExporter(prometheus.Options{
> 		Namespace: prefix,
> 	})
> 	if err != nil {
> 		log.Fatalf("Failed to create Prometheus exporter: %v", err)
> 	}
> 	view.RegisterExporter(pe)
> 	// We need to expose the Prometheus collector via an endpoint /metrics
> 	go func() {
> 		mux := http.NewServeMux()
> 		mux.Handle("/metrics", pe)
> 		log.Fatal(http.ListenAndServe(":9889", mux))
> 	}()
> 
> 	// 2. AWS X-Ray
> 	xe, err := xray.NewExporter(xray.WithVersion("latest"))
> 	if err != nil {
> 		log.Fatalf("Failed to create AWS X-Ray exporter: %v", err)
> 	}
> 	trace.RegisterExporter(xe)
> 
> 	// 3. Stackdriver Tracing and Monitoring
> 	se, err := stackdriver.NewExporter(stackdriver.Options{
> 		MetricPrefix: prefix,
> 	})
> 	if err != nil {
> 		log.Fatalf("Failed to create Stackdriver exporter: %v", err)
> 	}
> 	view.RegisterExporter(se)
> 	trace.RegisterExporter(se)
> }</code></pre></p><br />

							<p>or this which now becomes this code</p><br />
							
<p><pre><code>package main

import (
	"bufio"
	"context"
	"fmt"
	"log"
	"net/http"
	"os"

	"google.golang.org/grpc"

	xray "github.com/census-instrumentation/opencensus-go-exporter-aws"
	"go.opencensus.io/exporter/prometheus"
	"go.opencensus.io/exporter/stackdriver"
	"go.opencensus.io/plugin/ocgrpc"
	"go.opencensus.io/stats/view"
	"go.opencensus.io/trace"

	"./rpc"
)

func main() {
	serverAddr := ":9988"
	cc, err := grpc.Dial(serverAddr, grpc.WithInsecure(), grpc.WithStatsHandler(new(ocgrpc.ClientHandler)))
	if err != nil {
		log.Fatalf("fetchIt gRPC client failed to dial to server: %v", err)
	}
	fc := rpc.NewFetchClient(cc)

	// OpenCensus exporters for the client since disjoint
	// and your customers will usually want to have their
	// own statistics too.
	createAndRegisterExporters()
	if err := view.Register(ocgrpc.DefaultClientViews...); err != nil {
		log.Fatalf("Failed to register gRPC client views: %v", err)
	}

	fIn := bufio.NewReader(os.Stdin)
	for {
		fmt.Print("> ")
		line, _, err := fIn.ReadLine()
		if err != nil {
			log.Fatalf("Failed to read a line in: %v", err)
		}

		ctx, span := trace.StartSpan(context.Background(), "Client.Capitalize")
		out, err := fc.Capitalize(ctx, &amp;rpc.Payload{Data: line})
		span.End()
		if err != nil {
			log.Printf("fetchIt gRPC client got error from server: %v", err)
			continue
		}
		fmt.Printf("&lt; %s\n\n", out.Data)
	}
}

func createAndRegisterExporters() {
	// For demo purposes, set this to always sample.
	trace.ApplyConfig(trace.Config{DefaultSampler: trace.AlwaysSample()})
	// 1. Prometheus
	prefix := "fetchit"
	pe, err := prometheus.NewExporter(prometheus.Options{
		Namespace: prefix,
	})
	if err != nil {
		log.Fatalf("Failed to create Prometheus exporter: %v", err)
	}
	view.RegisterExporter(pe)
	// We need to expose the Prometheus collector via an endpoint /metrics
	go func() {
		mux := http.NewServeMux()
		mux.Handle("/metrics", pe)
		log.Fatal(http.ListenAndServe(":9889", mux))
	}()

	// 2. AWS X-Ray
	xe, err := xray.NewExporter(xray.WithVersion("latest"))
	if err != nil {
		log.Fatalf("Failed to create AWS X-Ray exporter: %v", err)
	}
	trace.RegisterExporter(xe)

	// 3. Stackdriver Tracing and Monitoring
	se, err := stackdriver.NewExporter(stackdriver.Options{
		MetricPrefix: prefix,
	})
	if err != nil {
		log.Fatalf("Failed to create Stackdriver exporter: %v", err)
	}
	view.RegisterExporter(se)
	trace.RegisterExporter(se)
}</code></pre></p><br />

							<p>which gives this visualization</p><br />

							<p><img src="https://cdn-images-1.medium.com/max/800/1*WisjA_lozi69PnHz7tMhdw.png" /></p><br /><br />

							<p><img src="https://cdn-images-1.medium.com/max/800/1*96_zFVZol6XkWODkkl8zyA.png" /></p><br /><br />

							<p><img src="https://cdn-images-1.medium.com/max/800/1*epDwWf-pNu0_VHi4md9ipw.png" /></p><br /><br />

							<p><img src="https://cdn-images-1.medium.com/max/800/1*znQiaxLKUd5Iv0xPetnG8g.png" /></p><br /><br />

							<p><img src="https://cdn-images-1.medium.com/max/800/1*4Qx_NM7t-Vfnv7BGqDUIoA.png" /></p><br />
							
							<p>Engineers can add alerts with Prometheus <a href="https://prometheus.io/docs/alerting/overview/" target="_blank"><span class="gloss1">https://prometheus.io/docs/alerting/overview/</span></a> or Stackdriver Monitoring <a href="https://cloud.google.com/monitoring/alerts/" target="_blank"><span class="gloss1">https://cloud.google.com/monitoring/alerts/</span></a> but also the various teams can examine system behaviour simultaneously, be it traces or metrics on a variety of backends. A question one might have is: “how about observability for streaming?” — for streaming you can use the same logic, but since in order to export a trace, the span needs to have been ended. However, with streaming, you have a single persistent connection that’s perhaps infinitely open. What you can do is register unique identifying information from a streaming request and then per stream response, start and end a span!</p><br />

							<p>With that we are off to the races!</p><br /><br /><br />

							<p>Thank you for reading this far and hope this tutorial was useful, you can find all the code in this tutorial at <a href="https://github.com/orijtech/opencensus-for-grpc-go-developers" target="_blank"><span class="gloss1">https://github.com/orijtech/opencensus-for-grpc-go-developers</span></a>.</p><br />

							<p>Please feel free to check out the OpenCensus community https://opencensus.io send us feedback, instrument your backends and share with your friends and teams!</p><br />

							<p>This tutorial is part of a bunch more coming where we’ll use different languages, different transports and provide more samples etc.</p><br />

							<p>Thank you again.</p><br />

							<p>Kind regards,</p><br />

							<p>Emmanuel T Odeke</p><br />
							
					   </div>
                        <!-- END CENTER COULMN -->
                        <!-- GO gRPC CONTENT END -->
                    </div>
                </div>
            </div>
        </section>
        <!-- ====== GO gRPC END  ======  -->


		<!-- ====== CONTACT START  ======  -->
		<section class="sections contact" id="contact">
			<div class="container">
				<div class="row">
                <div class="item">
                    <!-- FOOTER LINKS START -->
                    <!-- LEFTS LINKS FORM START -->
                    <div class="left-links">
					   <div class="col-md-6">
                            <p class="lead">OpenCensus</p>
                            <p>Copyright © OpenCensus 2018 | All Rights Reserved.</p>
                           <br>
					   </div>
                    </div>
					<!-- LEFT LINKS END -->
                    
                    <!-- RIGHT LINKS START -->
                    <!-- DOCUMENTS START -->
				    <div class="col-md-2">
                        <h6 class="ctit">Documents</h6>
                        <p><a href="overview.html">Overview</a></p><br>
                        <p><a href="quickstart.html">Quickstart</a></p><br>
                        <p><a href="guides.html">Guides</a></p><br>
                        <p><a href="https://github.com/census-instrumentation">Tutorials</a></p><br>
                        <p><a href="reference.html">API Reference</a></p><br>
					</div>
					<!-- DOCUMENTS END -->
					<!-- RESOURCES START -->
					<div class="col-md-2">
                        <h6 class="ctit">Resources</h6>
                        <p><a href="about.html">About</a></p><br>
                        <p><a href="blog.html">Blog</a></p><br>
                        <p><a href="faq.html">FAQ</a></p><br>
                        <p><a href="glossary.html">Glossary</a></p><br>
					</div>
					<!-- RESOURCES END  -->
                    <!-- COMMUNITY START  -->
					<div class="col-md-2">
						<h6 class="ctit">Community</h6>
                        <p><a href="community.html">Community</a></p><br>
                        <p><a href="https://github.com/census-instrumentation">Github</a></p><br>
                        <p><a href="https://twitter.com/opencensusio">Twitter</a></p><br>
                        <p><a href="https://www.facebook.com/opencensus">Facebook</a></p><br>
                        <p><a href="https://plus.google.com/communities/112482248706262039896">Google+</a></p><br>
                        <p><a href="https://gitter.im/census-instrumentation/Lobby">Gitter</a></p><br>
					</div>
					<!-- COMMUNITY END  -->
                    <!-- FOOTER LINKS END -->
                </div>                    
				</div>
			</div>
		</section>
		<!-- ====== CONTACT END  ======  -->


		<!-- ====== JS ======  -->
		<!-- JQUERY -->
		<script src="js/jquery.v1.12.4.js"></script>
		<!-- BOOTSTRAP JS -->
		<script src="js/bootstrap.min.js"></script>
		<!-- COUNT TO JS -->
		<script src="js/jquery.countTo.js"></script>
		<!-- ISOTOPE JS -->
		<script src="js/isotope.pkgd.min.js"></script>
		<!-- MASONRY JS -->
		<script src="js/masonry.pkgd.min.js"></script>
	    <!-- Magnific Popup core JS -->
	    <script src="js/jquery.magnific-popup.min.js"></script>
		<!-- PARSLEY file -->
	    <script src="js/parsley.js"></script>
		<!-- OWL CAROUSEL JS -->
		<script src="js/owl.carousel.min.js"></script>
	    <!-- SCROLLIT file -->
	    <script src="js/scrollIt.min.js"></script>
        <!-- ACCORDION JS -->
        <script src="js/accordion.js"></script>
		<!-- custom js -->
		<script src="js/main.js"></script>
	</body>
</html>